import "Std.Base"
import "Std.Functor"
import "Std.Maybe"
import "Std.Collections"

template List a implementing Collection a where
    Empty
    Cons  has
        head : a
        tail : List a

    implement function elemAt (i:Int) : a = if i == 0 then this.head else this.tail.elemAt (i-1)

    function (:) (x:a) : List a = List.Cons x this

    function null : Bool = this == List.Empty
    function empty : List a = []

    function map <b> (f: Function a b) : List b = this.foldr ((:) . f) (List.Empty)

    function take (am : Int) : List a = if this.null || am == 0 then this else this.head : this.tail.take (am-1)
    function drop (am : Int) : List a = if this.null || am == 0 then this else this.tail.drop (am-1)

    function foldl <b> (f: Function b (Function a b)) (acc : b) : b = if this.null then acc
        else this.tail.foldl f (f acc (this.head))

    function foldr <b> (f: Function a (Function b b)) (acc : b) : b = if this.null then acc
        else f (this.head) (this.tail.foldr f acc)

    function reverse : List a = this.foldl (:) []

    function zipWith <b,c> (f: Function a (Function b c)) (other : List b) : List c = if this.null || other.null then this.empty
        else (f (this.head)) (other.head) : this.tail.zipWith f (other.tail)

    function maybeHead : a = if this.null then Nothing else Maybe.Just (this.head)

    function (++) (l: List a) : List a = if this.null then l else this.head : this.tail ++ l

    static function replicate (amount:Int) (elem:a) : List a = if amount == 0 then [] else elem : List.replicate (amount-1) elem
