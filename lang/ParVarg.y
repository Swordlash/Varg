-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module ParVarg where
import AbsVarg
import LexVarg
import ErrM

}

%name pProgramDef ProgramDef
-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype {Token}
%token
  '(' { PT _ (TS _ 1) }
  ')' { PT _ (TS _ 2) }
  '*' { PT _ (TS _ 3) }
  '+' { PT _ (TS _ 4) }
  ',' { PT _ (TS _ 5) }
  '-' { PT _ (TS _ 6) }
  '->' { PT _ (TS _ 7) }
  '/' { PT _ (TS _ 8) }
  ':' { PT _ (TS _ 9) }
  ';' { PT _ (TS _ 10) }
  '<' { PT _ (TS _ 11) }
  '<=' { PT _ (TS _ 12) }
  '=' { PT _ (TS _ 13) }
  '==' { PT _ (TS _ 14) }
  '=>' { PT _ (TS _ 15) }
  '>' { PT _ (TS _ 16) }
  '>=' { PT _ (TS _ 17) }
  '[' { PT _ (TS _ 18) }
  '\\' { PT _ (TS _ 19) }
  ']' { PT _ (TS _ 20) }
  '^' { PT _ (TS _ 21) }
  '_' { PT _ (TS _ 22) }
  'abstract' { PT _ (TS _ 23) }
  'as' { PT _ (TS _ 24) }
  'class' { PT _ (TS _ 25) }
  'define' { PT _ (TS _ 26) }
  'deriving' { PT _ (TS _ 27) }
  'else' { PT _ (TS _ 28) }
  'final | unique' { PT _ (TS _ 29) }
  'function' { PT _ (TS _ 30) }
  'has' { PT _ (TS _ 31) }
  'if' { PT _ (TS _ 32) }
  'implement' { PT _ (TS _ 33) }
  'implementing' { PT _ (TS _ 34) }
  'import' { PT _ (TS _ 35) }
  'in' { PT _ (TS _ 36) }
  'interface' { PT _ (TS _ 37) }
  'internal' { PT _ (TS _ 38) }
  'internal | unique' { PT _ (TS _ 39) }
  'match' { PT _ (TS _ 40) }
  'module' { PT _ (TS _ 41) }
  'public' { PT _ (TS _ 42) }
  'sealed' { PT _ (TS _ 43) }
  'static' { PT _ (TS _ 44) }
  'struct' { PT _ (TS _ 45) }
  'super' { PT _ (TS _ 46) }
  'template' { PT _ (TS _ 47) }
  'then' { PT _ (TS _ 48) }
  'this' { PT _ (TS _ 49) }
  'where' { PT _ (TS _ 50) }
  'with' { PT _ (TS _ 51) }
  '{' { PT _ (TS _ 52) }
  '}' { PT _ (TS _ 53) }

L_integ  { PT _ (TI $$) }
L_doubl  { PT _ (TD $$) }
L_UIdent { PT _ (T_UIdent $$) }
L_LIdent { PT _ (T_LIdent $$) }
L_MFun { PT _ (T_MFun $$) }


%%

Integer :: { Integer } : L_integ  { (read ( $1)) :: Integer }
Double  :: { Double }  : L_doubl  { (read ( $1)) :: Double }
UIdent    :: { UIdent} : L_UIdent { UIdent ($1)}
LIdent    :: { LIdent} : L_LIdent { LIdent ($1)}
MFun    :: { MFun} : L_MFun { MFun ($1)}

ProgramDef :: { ProgramDef }
ProgramDef : ListImportDef ListClassDef { AbsVarg.Program (reverse $1) (reverse $2) }
ListClassDef :: { [ClassDef] }
ListClassDef : {- empty -} { [] }
             | ListClassDef ClassDef { flip (:) $1 $2 }
ImportDef :: { ImportDef }
ImportDef : 'import' UIdent ';' { AbsVarg.Import $2 }
ListImportDef :: { [ImportDef] }
ListImportDef : {- empty -} { [] }
              | ListImportDef ImportDef { flip (:) $1 $2 }
TypeParam :: { TypeParam }
TypeParam : LIdent { AbsVarg.InferredTypeParam $1 }
          | UIdent { AbsVarg.ConcreteTypeParam $1 }
ListConstrTypeParam :: { [ConstrTypeParam] }
ListConstrTypeParam : {- empty -} { [] }
                    | ListConstrTypeParam ConstrTypeParam { flip (:) $1 $2 }
ConstrTypeParam :: { ConstrTypeParam }
ConstrTypeParam : TypeParam { AbsVarg.UnconstrainedTypeParam $1 }
                | '[' TypeParam 'super' TypeDef ']' { AbsVarg.SuperConstrainedTypeParam $2 $4 }
                | '[' TypeParam 'deriving' TypeDef ']' { AbsVarg.DerivingConstrainedTypeParam $2 $4 }
ListArgDef :: { [ArgDef] }
ListArgDef : {- empty -} { [] }
           | ListArgDef ArgDef { flip (:) $1 $2 }
ArgDef :: { ArgDef }
ArgDef : '(' LIdent ':' TypeDef ')' { AbsVarg.ArgumentDefinition $2 $4 }
       | LIdent { AbsVarg.InferredArgumentDef $1 }
PrimType :: { PrimType }
PrimType : UIdent ListConstrTypeParam { AbsVarg.ConcreteType $1 (reverse $2) }
         | LIdent ListConstrTypeParam { AbsVarg.TemplateType $1 (reverse $2) }
TypeDef :: { TypeDef }
TypeDef : ListPrimType { AbsVarg.Type $1 } | TypeDef1 { $1 }
TypeDef1 :: { TypeDef }
TypeDef1 : '(' TypeDef ')' { $2 }
ListPrimType :: { [PrimType] }
ListPrimType : {- empty -} { [] }
             | PrimType { (:[]) $1 }
             | PrimType '->' ListPrimType { (:) $1 $3 }
ClassType :: { ClassType }
ClassType : UIdent TypeDef { AbsVarg.Class $1 $2 }
ListClassType :: { [ClassType] }
ListClassType : ClassType { (:[]) $1 }
              | ClassType ',' ListClassType { (:) $1 $3 }
ClassDef :: { ClassDef }
ClassDef : ListClassModifier 'struct' UIdent 'where' '{' ListClassField '}' { AbsVarg.StructDefinition (reverse $1) $3 $6 }
         | ListClassModifier 'class' UIdent IsImplementing IsDeriving 'where' '{' ClassContents '}' { AbsVarg.ClassDefinition (reverse $1) $3 $4 $5 $8 }
         | ListClassModifier 'template' UIdent ListConstrTypeParam IsImplementing IsDeriving 'where' '{' ClassContents '}' { AbsVarg.TemplateDefinition (reverse $1) $3 (reverse $4) $5 $6 $9 }
IsImplementing :: { IsImplementing }
IsImplementing : 'implementing' ListClassType { AbsVarg.Implementing $2 }
               | {- empty -} { AbsVarg.NotImplementing }
IsDeriving :: { IsDeriving }
IsDeriving : 'deriving' ClassType { AbsVarg.Deriving $2 }
           | {- empty -} { AbsVarg.NotDeriving }
ListClassModifier :: { [ClassModifier] }
ListClassModifier : {- empty -} { [] }
                  | ListClassModifier ClassModifier { flip (:) $1 $2 }
ClassModifier :: { ClassModifier }
ClassModifier : 'module' { AbsVarg.ClassModifier_module }
              | 'interface' { AbsVarg.ClassModifier_interface }
              | 'sealed' { AbsVarg.ClassModifier_sealed }
ClassContents :: { ClassContents }
ClassContents : ListMemberDef ListFunDef { AbsVarg.ClassContent $1 $2 }
MemberDef :: { MemberDef }
MemberDef : UIdent { AbsVarg.EmptyMemberDefinition $1 }
          | UIdent 'has' '{' ListClassField '}' { AbsVarg.MemberDefinition $1 $4 }
ListMemberDef :: { [MemberDef] }
ListMemberDef : {- empty -} { [] }
              | MemberDef { (:[]) $1 }
              | MemberDef ';' ListMemberDef { (:) $1 $3 }
FunDef :: { FunDef }
FunDef : ListFunctionModifier 'function' LIdent ListArgDef ':' TypeDef '=' Expr { AbsVarg.MemberFunctionDefinition (reverse $1) $3 (reverse $4) $6 $8 }
       | ListFunctionModifier 'function' LIdent ListArgDef ':' 'abstract' TypeDef { AbsVarg.AbstractFunctionDefinition (reverse $1) $3 (reverse $4) $7 }
ListFunDef :: { [FunDef] }
ListFunDef : {- empty -} { [] }
           | FunDef { (:[]) $1 }
           | FunDef ';' ListFunDef { (:) $1 $3 }
ListFunctionModifier :: { [FunctionModifier] }
ListFunctionModifier : {- empty -} { [] }
                     | ListFunctionModifier FunctionModifier { flip (:) $1 $2 }
FunctionModifier :: { FunctionModifier }
FunctionModifier : 'static' { AbsVarg.FunctionModifier_static }
                 | 'internal' { AbsVarg.FunctionModifier_internal }
                 | 'implement' { AbsVarg.FunctionModifier_implement }
                 | 'final | unique' { AbsVarg.FunctionModifier1 }
ClassField :: { ClassField }
ClassField : FieldModifier LIdent ':' TypeDef { AbsVarg.ModifiedClassField $1 $2 $4 }
           | LIdent ':' TypeDef { AbsVarg.NormalClassField $1 $3 }
ListClassField :: { [ClassField] }
ListClassField : {- empty -} { [] }
               | ClassField { (:[]) $1 }
               | ClassField ';' ListClassField { (:) $1 $3 }
FieldModifier :: { FieldModifier }
FieldModifier : 'public' { AbsVarg.FieldModifier_public }
              | 'internal | unique' { AbsVarg.FieldModifier1 }
Expr :: { Expr }
Expr : 'define' '{' ListAsDef '}' 'in' Expr { AbsVarg.EDefinitionsList $3 $6 }
     | 'define' AsDef 'in' Expr { AbsVarg.EDefinition $2 $4 }
     | 'match' Expr 'with' '{' ListMatchClause '}' { AbsVarg.EMatch $2 $5 }
     | 'if' Expr 'then' Expr 'else' Expr { AbsVarg.EIfThenElse $2 $4 $6 }
     | '(' '\\' ListArgDef ':' TypeDef '=>' Expr ')' { AbsVarg.ELambda (reverse $3) $5 $7 }
     | Expr1 { $1 }
ListAsDef :: { [AsDef] }
ListAsDef : {- empty -} { [] }
          | AsDef { (:[]) $1 }
          | AsDef ';' ListAsDef { (:) $1 $3 }
AsDef :: { AsDef }
AsDef : Expr 'as' LIdent { AbsVarg.IDefinition $1 $3 }
ListMatchClause :: { [MatchClause] }
ListMatchClause : {- empty -} { [] }
                | MatchClause { (:[]) $1 }
                | MatchClause ';' ListMatchClause { (:) $1 $3 }
MatchClause :: { MatchClause }
MatchClause : Expr '->' Expr { AbsVarg.IMatchClause $1 $3 }
Functorial :: { Functorial }
Functorial : 'this' { AbsVarg.ThisFunctor }
           | 'super' { AbsVarg.SuperFunctor }
           | UIdent { AbsVarg.TypeFunctor $1 }
           | LIdent { AbsVarg.InstanceFunctor $1 }
           | MFun { AbsVarg.MemberFunctor $1 }
Arg :: { Arg }
Arg : Expr6 { AbsVarg.ArgExpr $1 }
    | Functorial { AbsVarg.ArgFunc $1 }
ListArg :: { [Arg] }
ListArg : {- empty -} { [] } | ListArg Arg { flip (:) $1 $2 }
Expr5 :: { Expr }
Expr5 : Functorial ListArg { AbsVarg.EApply $1 (reverse $2) }
      | Integer { AbsVarg.EInt $1 }
      | Double { AbsVarg.EReal $1 }
      | '_' { AbsVarg.EWild }
      | Expr6 { $1 }
Expr1 :: { Expr }
Expr1 : Expr1 '==' Expr2 { AbsVarg.EEq $1 $3 }
      | Expr2 '<' Expr2 { AbsVarg.ELq $1 $3 }
      | Expr2 '>' Expr2 { AbsVarg.EGt $1 $3 }
      | Expr2 '<=' Expr2 { AbsVarg.ELeq $1 $3 }
      | Expr2 '>=' Expr2 { AbsVarg.EGeq $1 $3 }
      | Expr2 { $1 }
Expr2 :: { Expr }
Expr2 : Expr2 '+' Expr3 { AbsVarg.EAdd $1 $3 }
      | Expr2 '-' Expr3 { AbsVarg.ESub $1 $3 }
      | Expr3 { $1 }
Expr3 :: { Expr }
Expr3 : Expr3 '*' Expr4 { AbsVarg.EMul $1 $3 }
      | Expr3 '/' Expr4 { AbsVarg.EDiv $1 $3 }
      | Expr4 { $1 }
Expr4 :: { Expr }
Expr4 : Expr5 '^' Expr4 { AbsVarg.EPow $1 $3 } | Expr5 { $1 }
Expr6 :: { Expr }
Expr6 : '(' Expr ')' { $2 }
{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    _ -> " before " ++ unwords (map (id . prToken) (take 4 ts))

myLexer = tokens
}

