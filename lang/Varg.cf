comment "#" ;
comment "#/" "/#" ;

layout "define", "where", "has", "with";
layout stop "in";

entrypoints ProgramDef;

Program. ProgramDef ::= [ImportDef] [ClassDef] ;
terminator ClassDef "";

Import. ImportDef ::= "import" UIdent ";";
terminator ImportDef "";

token UIdent (upper (letter | digit)*);
token LIdent (lower (letter | digit)*);
token MFun ('.' (letter | digit)*);

------------------------ ANY Type, Constrained, unconstrained, wildcard -------------------------------

terminator                       ConstrTypeParam "";
InferredTypeParam.               ConstrTypeParam ::= LIdent ;
ConcreteTypeParam.               ConstrTypeParam ::= UIdent ;
WildcardTypeParam.               ConstrTypeParam ::= "?" ; 
AnotherClassTypeParam.           ConstrTypeParam ::= "(" TypeDef ")" ;
SuperConstrainedTypeParam.       ConstrTypeParam ::= "[" LIdent "super" [TypeDef] "]" ;
AnySuperConstrainedTypeParam.    ConstrTypeParam ::= "[" "?" "super" [TypeDef] "]" ;
DerivingConstrainedTypeParam.    ConstrTypeParam ::= "[" LIdent "deriving" [TypeDef] "]" ;
AnyDerivingConstrainedTypeParam. ConstrTypeParam ::= "[" "?" "deriving" [TypeDef] "]" ;

ConcreteType.               TypeDef ::= UIdent [ConstrTypeParam];
InferredType.               TypeDef ::= LIdent [ConstrTypeParam];
coercions                   TypeDef 1 ;
separator nonempty          TypeDef "," ;

--------------------------------- FREE type, unconstrained --------------------------------------------

ConcreteTypeFreeType.    PrimFreeType ::= "(" FreeTypeDef ")";
TemplateFreeType.        PrimFreeType ::= LIdent ;
ConcreteFreeType.        PrimFreeType ::= UIdent ;

FreeType.           FreeTypeDef ::= UIdent [PrimFreeType] ;
InferredFreeType.   FreeTypeDef ::= LIdent [PrimFreeType] ;
coercions           FreeTypeDef 1;
separator nonempty  FreeTypeDef "," ;
terminator          PrimFreeType "" ;


--------------------------------- Function arg, usually constrained -------------------------------------

terminator           ArgDef "";
ArgumentDefinition.  ArgDef    ::= "(" LIdent ":" TypeDef ")" ;
InferredArgumentDef. ArgDef    ::= LIdent ;

---------------------------------------------------------------------------------------------------------

Superclass.             SuperclassType ::= FreeTypeDef;
separator nonempty      SuperclassType ",";

StructDefinition.    ClassDef  ::= [ClassModifier] "struct" UIdent "where" "{" [ClassField] "}" ;                                                  -- structure definition
ClassDefinition.     ClassDef  ::= [ClassModifier] "class" UIdent IsDeriving IsImplementing "where" "{" ClassContents "}" ;                        -- class definition
TemplateDefinition.  ClassDef  ::= [ClassModifier] "template" UIdent [ConstrTypeParam] IsDeriving IsImplementing "where" "{" ClassContents "}" ;   -- template with type parameters

Implementing.     IsImplementing ::= "implementing" [SuperclassType] ;
NotImplementing.  IsImplementing ::= ;

Deriving.    IsDeriving ::= "deriving" SuperclassType ;
NotDeriving. IsDeriving ::= ;

terminator ClassModifier "";
rules      ClassModifier ::= "module" | "interface" | "sealed" ; -- module class is internal to module, all others are exported, sealed is not to be inherited

ClassContent. ClassContents ::= [MemberDef] [FunDef] ;

EmptyMemberDefinition. MemberDef ::= UIdent; -- variant type definition, like Either . Left / Right
MemberDefinition.      MemberDef ::= UIdent "has" "{" [ClassField] "}" ; -- variant type with own fields 
separator              MemberDef ";" ;

MemberFunctionDefinition.    FunDef ::= [FunctionModifier] "function" LIdent [ArgDef] RetType "=" Expr ;
ReturnType.                  RetType ::= ":" FreeTypeDef ;
InferredReturnType.          RetType ::= ;

AbstractFunctionDefinition.  FunDef ::= [FunctionModifier] "function" LIdent [ArgDef] AbsRetType ; -- abstract function, to be implemented in subclasses
AbsReturnType.               AbsRetType ::= ":" "abstract" FreeTypeDef ;
AbsInferredReturnType.       AbsRetType ::= ;

separator                    FunDef ";";

terminator FunctionModifier "";
rules      FunctionModifier ::= "static" | "internal" | "implement" | "final" | "unique" ; -- like in Java, internal means private

ModifiedClassField.   ClassField ::= FieldModifier LIdent ":" FreeTypeDef ;
NormalClassField.     ClassField ::= LIdent ":" FreeTypeDef ;
separator             ClassField ";";

rules FieldModifier ::= "internal" | "unique" ;

EDefinitionsList.   Expr   ::= "define" "{" [AsDef] "}" "in" Expr ; -- example: 'define 34 as x in 7*x', with list variant
EDefinition.        Expr   ::= "define" AsDef "in" Expr           ;

separator         AsDef ";" ;
IDefinition.      AsDef ::= Expr "as" LIdent ;

EMatch.             Expr  ::= "match" Expr "with" "{" [MatchClause] "}" ; -- e.g., 'match this with { Either.Left a -> ...; Either.Right a -> ...}'

separator     MatchClause ";" ;
IMatchClause. MatchClause ::= Expr "->" Expr;

EIfThenElse.        Expr  ::= "if" Expr "then" Expr "else" Expr ;

ThisFunctor.     Functorial ::= "this" ;
SuperFunctor.    Functorial ::= "super";
TypeFunctor.     Functorial ::= UIdent ;
InstanceFunctor. Functorial ::= LIdent ;
MemberFunctor.   Functorial ::= MFun ;

ArgExpr.            Arg ::= Expr6 ;
ArgFunc.            Arg ::= Functorial ; 
terminator          Arg "";

EApply.             Expr5 ::= Functorial [Arg] ;

ELambda.            Expr ::= "(" "\\" [ArgDef] ":" TypeDef "=>" Expr ")" ; -- lambda expr

EList.              Expr ::= "[" [ListElem] "]" ;
EListElem.          ListElem ::= Expr ;
separator           ListElem ",";

EEq.                Expr1  ::= Expr1  "==" Expr2 ;
ELq.                Expr1  ::= Expr2 "<"  Expr2 ;
EGt.                Expr1  ::= Expr2 ">"  Expr2 ;
ELeq.               Expr1  ::= Expr2 "<=" Expr2 ;
EGeq.               Expr1  ::= Expr2 ">=" Expr2 ;
EAdd.               Expr2 ::= Expr2 "+"  Expr3 ;
ESub.               Expr2 ::= Expr2 "-"  Expr3 ;
EMul.               Expr3 ::= Expr3 "*"  Expr4 ;
EDiv.               Expr3 ::= Expr3 "/"  Expr4 ;
EPow.               Expr4 ::= Expr5 "^"  Expr4 ;

EInt.               Expr6 ::= Integer ;
EReal.              Expr6 ::= Double  ;
EWild.              Expr6 ::= "_"     ; -- wildcard variable used for matching or saving identifiers

coercions           Expr 6 ;
