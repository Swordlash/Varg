comment "#" ;
comment "#/" "/#" ;

layout "define", "where", "has", "with";
layout stop "in";

entrypoints ProgramDef;

Program. ProgramDef ::= [ImportDef] [ClassDef] ;
terminator ClassDef "";

Import. ImportDef ::= "import" UIdent ";";
terminator ImportDef "";

token UIdent (upper (letter | digit)*);
token LIdent (lower (letter | digit)*);

token MFun ('.' (letter | digit)*);

------------------------ ANY Type, Constrained, unconstrained, wildcard -------------------------------

terminator                       ConstrTypeParam "";
InferredTypeParam.               ConstrTypeParam ::= LIdent ;
ConcreteTypeParam.               ConstrTypeParam ::= UIdent ;
WildcardTypeParam.               ConstrTypeParam ::= "?" ; 
--AnotherClassTypeParam.           ConstrTypeParam ::= "(" TypeDef ")" ;
SuperConstrainedTypeParam.       ConstrTypeParam ::= "[" LIdent "super" [TypeDef] "]" ;
AnySuperConstrainedTypeParam.    ConstrTypeParam ::= "[" "?" "super" [TypeDef] "]" ;
DerivingConstrainedTypeParam.    ConstrTypeParam ::= "[" LIdent "deriving" [TypeDef] "]" ;
AnyDerivingConstrainedTypeParam. ConstrTypeParam ::= "[" "?" "deriving" [TypeDef] "]" ;

ConcreteType.               TypeDef ::= UIdent [ConstrTypeParam];
InferredType.               TypeDef ::= LIdent [ConstrTypeParam];
coercions                   TypeDef 1 ;
separator nonempty          TypeDef "," ;

--------------------------------- FREE type, unconstrained ----------------------------------------------

ConcreteTypeFreeType.    PrimFreeType ::= "(" FreeTypeDef ")";
TemplateFreeType.        PrimFreeType ::= LIdent ;
ConcreteFreeType.        PrimFreeType ::= UIdent ;

FreeType.           FreeTypeDef ::= UIdent [PrimFreeType] ;
InferredFreeType.   FreeTypeDef ::= LIdent [PrimFreeType] ;
coercions           FreeTypeDef 1;
terminator          PrimFreeType "" ;


--------------------------------- Function arg, usually constrained -------------------------------------

terminator ArgDef "";
ArgumentDefinition.  ArgDef    ::= "(" LIdent ":" FreeTypeDef ")" ;
InferredArgumentDef. ArgDef    ::= LIdent ;

---------------------------------------------------------------------------------------------------------

Superclass.             SuperclassType ::= FreeTypeDef;
separator nonempty      SuperclassType ",";

StructDefinition.    ClassDef  ::= [ClassModifier] "struct" UIdent "where" "{" [ClassField] "}" ;                                                  -- structure definition
ClassDefinition.     ClassDef  ::= [ClassModifier] "class" UIdent IsDeriving IsImplementing "where" "{" ClassContents "}" ;                        -- class definition
TemplateDefinition.  ClassDef  ::= [ClassModifier] "template" UIdent [ConstrTypeParam] IsDeriving IsImplementing "where" "{" ClassContents "}" ;   -- template with type parameters

Implementing.     IsImplementing ::= "implementing" [SuperclassType] ;
NotImplementing.  IsImplementing ::= ;

Deriving.    IsDeriving ::= "deriving" SuperclassType ;
NotDeriving. IsDeriving ::= ;

terminator ClassModifier "";
rules      ClassModifier ::= "module" | "interface" | "sealed" | "native" ; -- module class is internal to module, all others are exported, sealed is not to be inherited

ClassContent. ClassContents ::= [MemberDef] [FunDef] ;

EmptyMemberDefinition. MemberDef ::= UIdent; -- variant type definition, like Either . Left / Right
MemberDefinition.      MemberDef ::= UIdent "has" "{" [ClassField] "}" ; -- variant type with own fields 
separator              MemberDef ";" ;

MemberFunctionDefinition.    FunDef ::= [FunctionModifier] "function" FunctionName FunTemplateParams [ArgDef] RetType "=" Expr ;
ReturnType.                  RetType ::= ":" FreeTypeDef ;
InferredReturnType.          RetType ::= ;

FFunction.   FunctionName ::= LIdent ;
FOperator.   FunctionName ::= "(" Operator ")" ;

Op_plus.  Operator ::= "+" ;
Op_minus. Operator ::= "-" ;
Op_mul.   Operator ::= "*" ;
Op_div.   Operator ::= "/" ;
Op_pow.   Operator ::= "^" ;
Op_less.  Operator ::= "<" ;
Op_gr.    Operator ::= ">" ;
Op_leq.   Operator ::= "<=";
Op_geq.   Operator ::= ">=";
Op_eq.    Operator ::= "==";

AbstractFunctionDefinition.  FunDef ::= [FunctionModifier] "function" FunctionName FunTemplateParams [ArgDef] AbsRetType ; -- abstract function, to be implemented in subclasses
AbsReturnType.               AbsRetType ::= ":" "abstract" FreeTypeDef ;
AbsInferredReturnType.       AbsRetType ::= ;

NoFunctionTemplateParameter. FunTemplateParams ::= ;
FunctionTemplateParameters.  FunTemplateParams ::= "<" [TemplateParam] ">" ;
TemplateParameter.           TemplateParam     ::= ConstrTypeParam ;
separator nonempty           TemplateParam "," ;

separator                    FunDef ";";

terminator FunctionModifier "";
rules      FunctionModifier ::= "static" | "internal" | "implement" | "final" | "unique" | "native" ; -- like in Java, internal means private

ModifiedClassField.   ClassField ::= FieldModifier LIdent ":" FreeTypeDef ;
NormalClassField.     ClassField ::= LIdent ":" FreeTypeDef ;
separator             ClassField ";";

rules FieldModifier ::= "internal" | "unique" ;

EDefinitionsList.   Expr   ::= "define" "{" [AsDef] "}" "in" Expr ; -- example: 'define 34 as x in 7*x', with list variant
EDefinition.        Expr   ::= "define" AsDef "in" Expr           ;

separator         AsDef ";" ;
IDefinition.      AsDef ::= Expr "as" LIdent ;

EMatch.             Expr  ::= "match" Expr "with" "{" [MatchClause] "}" ; -- e.g., 'match this with { Either.Left a -> ...; Either.Right a -> ...}'

separator nonempty  MatchClause ";" ;
IMatchClause.       MatchClause ::= Expr "->" Expr;

EIfThenElse.        Expr  ::= "if" Expr "then" Expr "else" Expr ;

ThisFunctor.     Functorial ::= "this" ;
SuperFunctor.    Functorial ::= "super";
TypeFunctor.     Functorial ::= UIdent ;
InstanceFunctor. Functorial ::= LIdent ;
MemberFunctor.   Functorial ::= MFun ;
OperatorFunctor. Functorial ::= "(" Operator ")" ;
ExprFunctor.     Functorial ::= "(" Expr6 ")" ;

ArgExpr.            Arg ::= Expr6 ;
ArgFunc.            Arg ::= Functorial ; 
terminator          Arg "";

EApply.             Expr5 ::= Functorial [Arg] ;

ELambda.            Expr ::= "(" "\\" [ArgDef] ":" TypeDef "=>" Expr ")" ; -- lambda expr

EList.              Expr ::= "[" [ListElem] "]" ;
EListElem.          ListElem ::= Expr ;
separator           ListElem ",";

EEq.                Expr1  ::= Expr1  "==" Expr2 ;
EMod.               Expr1  ::= Expr2 "mod" Expr2;
ENot.               Expr1  ::= "not" Expr2;
EOr.                Expr1  ::= Expr2 "||" Expr2;
EAnd.               Expr1  ::= Expr2 "&&" Expr2;
ELt.                Expr1  ::= Expr2 "<"  Expr2 ;
EGt.                Expr1  ::= Expr2 ">"  Expr2 ;
ELeq.               Expr1  ::= Expr2 "<=" Expr2 ;
EGeq.               Expr1  ::= Expr2 ">=" Expr2 ;
EAdd.               Expr2 ::= Expr2 "+"  Expr3 ;
ESub.               Expr2 ::= Expr2 "-"  Expr3 ;
EMul.               Expr3 ::= Expr3 "*"  Expr4 ;
EDiv.               Expr3 ::= Expr3 "/"  Expr4 ;
EPow.               Expr4 ::= Expr5 "^"  Expr4 ;

EBoolean.           Expr6 ::= Boolean ;
ETrue.              Boolean  ::= "true" ;
EFalse.             Boolean  ::= "false" ; 

EInt.               Expr6 ::= Integer ;
EReal.              Expr6 ::= Double  ;
EChar.              Expr6 ::= "'" Char "'" ;
EString.            Expr6 ::= "\""  String "\""; 
EWild.              Expr6 ::= "_"     ; -- wildcard variable used for matching or saving identifiers

coercions           Expr 6 ;
