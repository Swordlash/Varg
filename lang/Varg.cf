comment "#" ;
comment "#{" "}#" ;

layout "let", "where", "has", "with";
layout stop "in";

token UIdent (upper (letter | digit)*);
token LIdent (lower (letter | digit)*);

token MFun ('.' (letter | digit)*);
token Op ( '!' | '#' | '$' | '%' | '&' | '*' | '+' | '.' | '/' | '<' | '=' | '>' | '?' | '@' | '\\' | '^' | '|' | '-' | '~' )+ ;

entrypoints ProgramDef;

Program. ProgramDef ::= [ImportDef] [ClassDef] ;
terminator ClassDef "";

Import. ImportDef ::= "import" String;
terminator ImportDef "";

------------------------ ANY Type, Constrained, unconstrained, wildcard -------------------------------

terminator                       ConstrTypeParam "";
InferredTypeParam.               ConstrTypeParam ::= LIdent ;
ConcreteTypeParam.               ConstrTypeParam ::= UIdent ;
WildcardTypeParam.               ConstrTypeParam ::= "?" ; 
--AnotherClassTypeParam.           ConstrTypeParam ::= "(" TypeDef ")" ;
SuperConstrainedTypeParam.       ConstrTypeParam ::= "[" LIdent "super" [TypeDef] "]" ;
AnySuperConstrainedTypeParam.    ConstrTypeParam ::= "[" "?" "super" [TypeDef] "]" ;
DerivingConstrainedTypeParam.    ConstrTypeParam ::= "[" LIdent "deriving" [TypeDef] "]" ;
AnyDerivingConstrainedTypeParam. ConstrTypeParam ::= "[" "?" "deriving" [TypeDef] "]" ;

ConcreteType.               TypeDef ::= UIdent [ConstrTypeParam];
InferredType.               TypeDef ::= LIdent [ConstrTypeParam];
coercions                   TypeDef 1 ;
separator nonempty          TypeDef "," ;

--------------------------------- FREE type, unconstrained ----------------------------------------------

ConcreteTypeFreeType.    PrimFreeType ::= "(" FreeTypeDef ")";
TemplateFreeType.        PrimFreeType ::= LIdent ;
ConcreteFreeType.        PrimFreeType ::= UIdent ;

FreeType.           FreeTypeDef ::= UIdent [PrimFreeType] ;
InferredFreeType.   FreeTypeDef ::= LIdent [PrimFreeType] ;
coercions           FreeTypeDef 1;
terminator          PrimFreeType "" ;


--------------------------------- Function arg, usually constrained -------------------------------------

terminator ArgDef "";
ArgumentDefinition.  ArgDef    ::= "(" LIdent ":" FreeTypeDef ")" ;
InferredArgumentDef. ArgDef    ::= LIdent ;

---------------------------------------------------------------------------------------------------------

Superclass.             SuperclassType ::= FreeTypeDef;
separator nonempty      SuperclassType ",";

StructDefinition.    ClassDef  ::= [ClassModifier] "struct" UIdent "where" "{" [ClassField] "}" ;                                                  -- structure definition
ClassDefinition.     ClassDef  ::= [ClassModifier] "class" UIdent IsDeriving IsImplementing "where" "{" ClassContents "}" ;                        -- class definition
TemplateDefinition.  ClassDef  ::= [ClassModifier] "template" UIdent [ConstrTypeParam] IsDeriving IsImplementing "where" "{" ClassContents "}" ;   -- template with type parameters

Implementing.     IsImplementing ::= "implementing" [SuperclassType] ;
NotImplementing.  IsImplementing ::= ;

Deriving.    IsDeriving ::= "deriving" SuperclassType ;
NotDeriving. IsDeriving ::= ;

terminator ClassModifier "";
rules      ClassModifier ::= "module" | "interface" | "sealed" | "native" ; -- module class is internal to module, all others are exported, sealed is not to be inherited

ClassContent. ClassContents ::= [MemberDef] [FunDef] ;

EmptyMemberDefinition. MemberDef ::= UIdent; -- variant type definition, like Either . Left / Right
MemberDefinition.      MemberDef ::= UIdent "has" "{" [ClassField] "}" ; -- variant type with own fields 
separator              MemberDef ";" ;

MemberFunctionDefinition.    FunDef ::= [FunctionModifier] "function" FunctionName FunTemplateParams [ArgDef] RetType "=" Expr ;
ReturnType.                  RetType ::= ":" FreeTypeDef ;
InferredReturnType.          RetType ::= ;

FFunction.    FunctionName ::= LIdent ;
FOperator.    FunctionName ::= "(" Operator ")" ;
FOperatorDef. FunctionName ::= "(" Op ")";


Op_plus.  Operator ::= "+" ;
Op_minus. Operator ::= "-" ;
Op_mul.   Operator ::= "*" ;
Op_div.   Operator ::= "/" ;
Op_pow.   Operator ::= "^" ;
Op_less.  Operator ::= "<" ;
Op_gr.    Operator ::= ">" ;
Op_leq.   Operator ::= "<=";
Op_geq.   Operator ::= ">=";
Op_eq.    Operator ::= "==";
Op_cons.  Operator ::= ":" ;

AbstractFunctionDefinition.  FunDef ::= [FunctionModifier] "function" FunctionName FunTemplateParams [ArgDef] AbsRetType ; -- abstract function, to be implemented in subclasses
AbsReturnType.               AbsRetType ::= ":" "abstract" FreeTypeDef ;
AbsInferredReturnType.       AbsRetType ::= ;

NoFunctionTemplateParameter. FunTemplateParams ::= ;
FunctionTemplateParameters.  FunTemplateParams ::= "<" [TemplateParam] ">" ;
TemplateParameter.           TemplateParam     ::= ConstrTypeParam ;
separator nonempty           TemplateParam "," ;

separator                    FunDef ";";

terminator FunctionModifier "";
rules      FunctionModifier ::= "static" | "internal" | "implement" | "final" | "unique" | "native" ; -- like in Java, internal means private

ModifiedClassField.   ClassField ::= FieldModifier LIdent ":" FreeTypeDef ;
NormalClassField.     ClassField ::= LIdent ":" FreeTypeDef ;
separator             ClassField ";";

rules FieldModifier ::= "internal" | "unique" ;

EDefinitionsList.   Expr   ::= "let" "{" [LetDef] "}" "in" Expr ; 
EDefinition.        Expr   ::= "let" LetDef "in" Expr           ;

separator nonempty   LetDef ";" ;
IDefinition.         LetDef ::= LIdent [ArgDef] ":" FreeTypeDef "=" Expr;
IInferredDefinition. LetDef ::= LIdent [ArgDef] "=" Expr;

EMatch.             Expr  ::= "match" Expr "with" "{" [MatchClause] "}" ;

separator nonempty  MatchClause ";" ;
IMatchClause.       MatchClause ::= Expr "->" Expr;

EIfThenElse.        Expr  ::= "if" Expr "then" Expr "else" Expr ;
EUnify.             Expr  ::= "unify" Expr "with" Expr "in" Expr;

ELambda.            Expr6 ::= "(" "\\" [ArgDef] ":" TypeDef "->" Expr ")" ; -- lambda expr
EInferredLambda.    Expr6 ::= "(" "\\" [ArgDef] "->" Expr ")" ;

EList.              Expr6 ::= "[" [ListElem] "]" ;
EEmptyList.         Expr6 ::= "[]" ;
ERange.             Expr6 ::= "[" Integer ".." Integer "]" ;
EListElem.          ListElem ::= Expr ;
separator nonempty  ListElem ",";

ENeg.               Expr5  ::= "-" Expr6 ;
ECons.              Expr  ::= Expr1 ":"   Expr;
EOp.                Expr1  ::= Expr1 Op Expr2;
EEq.                Expr1  ::= Expr1  "==" Expr2 ;
ENeq.               Expr1  ::= Expr1  "/=" Expr2 ;
EMod.               Expr1  ::= Expr2 "mod" Expr2;
ENot.               Expr1  ::= "not" Expr2;
EOr.                Expr1  ::= Expr2 "||" Expr2;
EAnd.               Expr1  ::= Expr2 "&&" Expr2;
ELt.                Expr1  ::= Expr2 "<"  Expr2 ;
EGt.                Expr1  ::= Expr2 ">"  Expr2 ;
ELeq.               Expr1  ::= Expr2 "<=" Expr2 ;
EGeq.               Expr1  ::= Expr2 ">=" Expr2 ;
EAdd.               Expr2 ::= Expr2 "+"  Expr3 ;
ESub.               Expr2 ::= Expr2 "-"  Expr3 ;
EMul.               Expr3 ::= Expr3 "*"  Expr4 ;
EDiv.               Expr3 ::= Expr3 "/"  Expr4 ;
EPow.               Expr4 ::= Expr5 "^"  Expr4 ;

EBoolean.           Expr6 ::= Boolean ;
ETrue.              Boolean  ::= "true" ;
EFalse.             Boolean  ::= "false" ; 
EThis.              Expr6 ::= "this";
ESuper.             Expr6 ::= "super";
EVar.               Expr6 ::= LIdent ;
EType.              Expr6 ::= UIdent ;
EMember.            Expr6 ::= MFun ;
EOperator.          Expr6 ::= "(" Operator ")" ;

EInt.               Expr6 ::= Integer ;
EReal.              Expr6 ::= Double  ;
EChar.              Expr6 ::= Char ;
EString.            Expr6 ::= String ;
EWild.              Expr6 ::= "_"     ; -- wildcard variable used for matching or saving identifiers

EApply.             Expr5 ::= Expr5 Expr6 ;

coercions           Expr 6 ;
